// Mining Incentives Integration
// Connects marketplace problems to mining rewards with D3 bounty pool

use crate::marketplace::ProblemMarketplace;
use coinject_core::{Address, Balance, Hash, ProblemType, Solution, WorkScore};
use coinject_tokenomics::DimensionalDistributor;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Enhanced reward breakdown for marketplace-integrated mining
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct EnhancedReward {
    /// Base mining reward from work score
    pub base_reward: Balance,
    /// Marketplace bounty (if solving marketplace problem)
    pub marketplace_bounty: Balance,
    /// D3 dimensional allocation bonus
    pub d3_bonus: Balance,
    /// Total reward
    pub total_reward: Balance,
    /// Problem source
    pub source: RewardSource,
}

/// Source of the mining problem
#[derive(Clone, Debug, PartialEq, Eq, Serialize, Deserialize)]
pub enum RewardSource {
    /// Random problem generated by miner
    RandomGenerated,
    /// Marketplace problem with bounty
    MarketplaceProblem(Hash),
}

/// Mining incentive manager
pub struct MiningIncentives {
    /// Reference to marketplace
    marketplace: ProblemMarketplace,
    /// Dimensional distributor for D3 allocation
    distributor: DimensionalDistributor,
    /// D3 bounty pool accumulated from block rewards
    d3_pool: Balance,
    /// Marketplace problem selection weights
    problem_weights: HashMap<Hash, f64>,
}

impl MiningIncentives {
    pub fn new(marketplace: ProblemMarketplace) -> Self {
        MiningIncentives {
            marketplace,
            distributor: DimensionalDistributor::new(),
            d3_pool: 0,
            problem_weights: HashMap::new(),
        }
    }

    /// Contribute to D3 bounty pool from block rewards
    /// Called after each block is mined
    pub fn contribute_to_d3_pool(&mut self, block_reward: Balance) {
        let allocation = self.distributor.distribute(block_reward);
        self.d3_pool += allocation.bounty_pool; // D3: Problem bounty pool

        println!(
            "D3 pool contribution: {} (pool now: {})",
            allocation.bounty_pool, self.d3_pool
        );
    }

    /// Get the most valuable marketplace problem for mining
    /// Considers bounty size, difficulty, and time remaining
    pub fn select_best_marketplace_problem(&self) -> Option<(Hash, ProblemType, Balance)> {
        let open_problems = self.marketplace.get_open_problems();

        if open_problems.is_empty() {
            return None;
        }

        // Find problem with highest total reward potential
        let mut best_problem = None;
        let mut max_value = 0.0;

        for problem in open_problems {
            // Calculate value score: bounty + expected D3 bonus - time penalty
            let time_factor = self.calculate_time_factor(problem.submitted_at, problem.expires_at);
            let value = (problem.bounty as f64) * time_factor;

            if value > max_value {
                max_value = value;
                best_problem = Some((
                    problem.problem_id,
                    problem.problem.clone(),
                    problem.bounty,
                ));
            }
        }

        best_problem
    }

    /// Calculate time urgency factor (higher near expiration)
    fn calculate_time_factor(&self, submitted_at: i64, expires_at: i64) -> f64 {
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs() as i64;

        let total_time = expires_at - submitted_at;
        let elapsed = now - submitted_at;
        let remaining = expires_at - now;

        if remaining <= 0 {
            return 0.0; // Expired
        }

        // Urgency increases as expiration approaches
        let urgency = 1.0 + (elapsed as f64 / total_time as f64);
        urgency.min(2.0) // Cap at 2x multiplier
    }

    /// Calculate enhanced reward for mining a block
    pub fn calculate_enhanced_reward(
        &self,
        base_reward: Balance,
        problem_source: &RewardSource,
        work_score: WorkScore,
    ) -> EnhancedReward {
        match problem_source {
            RewardSource::RandomGenerated => {
                // No marketplace bonus for random problems
                EnhancedReward {
                    base_reward,
                    marketplace_bounty: 0,
                    d3_bonus: 0,
                    total_reward: base_reward,
                    source: problem_source.clone(),
                }
            }
            RewardSource::MarketplaceProblem(problem_id) => {
                // Get marketplace bounty
                let marketplace_bounty = self
                    .marketplace
                    .get_problem(problem_id)
                    .map(|p| p.bounty)
                    .unwrap_or(0);

                // Calculate D3 bonus based on work score
                // Higher work score = larger D3 bonus
                let d3_bonus = self.calculate_d3_bonus(work_score, marketplace_bounty);

                let total_reward = base_reward + marketplace_bounty + d3_bonus;

                EnhancedReward {
                    base_reward,
                    marketplace_bounty,
                    d3_bonus,
                    total_reward,
                    source: problem_source.clone(),
                }
            }
        }
    }

    /// Calculate D3 bonus from pool based on work score and bounty
    fn calculate_d3_bonus(&self, work_score: WorkScore, marketplace_bounty: Balance) -> Balance {
        if self.d3_pool == 0 {
            return 0;
        }

        // Bonus is proportional to:
        // 1. Work score (higher work = higher bonus)
        // 2. Marketplace bounty (larger bounties get matched)
        // Cap at 50% of marketplace bounty or 10% of D3 pool
        let work_factor = (work_score / 100.0).min(1.0); // Normalize to 0-1
        let max_bonus_from_bounty = (marketplace_bounty as f64 * 0.5) as Balance;
        let max_bonus_from_pool = (self.d3_pool as f64 * 0.1) as Balance;

        let bonus = ((marketplace_bounty as f64) * work_factor) as Balance;
        bonus.min(max_bonus_from_bounty).min(max_bonus_from_pool)
    }

    /// Deduct D3 bonus from pool after payout
    pub fn deduct_d3_bonus(&mut self, bonus: Balance) {
        self.d3_pool = self.d3_pool.saturating_sub(bonus);
        println!("D3 pool after bonus payout: {}", self.d3_pool);
    }

    /// Submit solution from mining to marketplace
    pub fn submit_mining_solution(
        &mut self,
        problem_id: Hash,
        miner: Address,
        solution: Solution,
    ) -> Result<Balance, String> {
        self.marketplace
            .submit_solution(problem_id, miner, solution)
            .map_err(|e| format!("Failed to submit solution: {}", e))?;

        // Immediately claim bounty for miner
        let (_, bounty) = self
            .marketplace
            .claim_bounty(problem_id)
            .map_err(|e| format!("Failed to claim bounty: {}", e))?;

        Ok(bounty)
    }

    /// Get marketplace reference
    pub fn marketplace(&self) -> &ProblemMarketplace {
        &self.marketplace
    }

    /// Get mutable marketplace reference
    pub fn marketplace_mut(&mut self) -> &mut ProblemMarketplace {
        &mut self.marketplace
    }

    /// Get current D3 pool balance
    pub fn d3_pool_balance(&self) -> Balance {
        self.d3_pool
    }

    /// Get statistics about mining incentives
    pub fn get_stats(&self) -> IncentiveStats {
        let marketplace_stats = self.marketplace.get_stats();

        IncentiveStats {
            d3_pool_balance: self.d3_pool,
            open_bounties: marketplace_stats.open_problems,
            total_bounty_value: marketplace_stats.total_bounty_pool,
            solved_problems: marketplace_stats.solved_problems,
        }
    }
}

/// Mining incentive statistics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IncentiveStats {
    pub d3_pool_balance: Balance,
    pub open_bounties: usize,
    pub total_bounty_value: Balance,
    pub solved_problems: usize,
}

#[cfg(test)]
mod tests {
    use super::*;
    use coinject_core::{Address, ProblemType, Solution};

    #[test]
    fn test_d3_pool_contribution() {
        let marketplace = ProblemMarketplace::new();
        let mut incentives = MiningIncentives::new(marketplace);

        // Simulate block reward
        let block_reward = 10000;
        incentives.contribute_to_d3_pool(block_reward);

        // D3 allocation should be 42.1% normalized
        assert!(incentives.d3_pool_balance() > 0);
        assert!(incentives.d3_pool_balance() < block_reward);
    }

    #[test]
    fn test_enhanced_reward_random_problem() {
        let marketplace = ProblemMarketplace::new();
        let incentives = MiningIncentives::new(marketplace);

        let base_reward = 1000;
        let source = RewardSource::RandomGenerated;

        let reward = incentives.calculate_enhanced_reward(base_reward, &source, 50.0);

        assert_eq!(reward.base_reward, base_reward);
        assert_eq!(reward.marketplace_bounty, 0);
        assert_eq!(reward.d3_bonus, 0);
        assert_eq!(reward.total_reward, base_reward);
    }

    #[test]
    fn test_enhanced_reward_marketplace_problem() {
        let mut marketplace = ProblemMarketplace::new();

        let problem = ProblemType::SubsetSum {
            numbers: vec![1, 2, 3, 4, 5],
            target: 9,
        };

        let submitter = Address::from_bytes([1u8; 32]);
        let bounty = 5000;

        let problem_id = marketplace
            .submit_problem(problem, submitter, bounty, 10.0, 7)
            .unwrap();

        let mut incentives = MiningIncentives::new(marketplace);

        // Add to D3 pool
        incentives.contribute_to_d3_pool(10000);

        let base_reward = 1000;
        let source = RewardSource::MarketplaceProblem(problem_id);

        let reward = incentives.calculate_enhanced_reward(base_reward, &source, 80.0);

        assert_eq!(reward.base_reward, base_reward);
        assert_eq!(reward.marketplace_bounty, bounty);
        assert!(reward.d3_bonus > 0);
        assert_eq!(
            reward.total_reward,
            base_reward + bounty + reward.d3_bonus
        );
    }

    #[test]
    fn test_select_best_marketplace_problem() {
        let mut marketplace = ProblemMarketplace::new();

        let problem1 = ProblemType::SubsetSum {
            numbers: vec![1, 2, 3],
            target: 6,
        };

        let problem2 = ProblemType::SubsetSum {
            numbers: vec![4, 5, 6],
            target: 11,
        };

        let submitter = Address::from_bytes([1u8; 32]);

        marketplace.submit_problem(problem1, submitter, 1000, 10.0, 7).unwrap();
        marketplace.submit_problem(problem2, submitter, 5000, 10.0, 7).unwrap();

        let incentives = MiningIncentives::new(marketplace);
        let best = incentives.select_best_marketplace_problem();

        assert!(best.is_some());
        let (_, _, bounty) = best.unwrap();

        // Should select higher bounty problem
        assert_eq!(bounty, 5000);
    }

    #[test]
    fn test_mining_solution_submission() {
        let mut marketplace = ProblemMarketplace::new();

        let problem = ProblemType::SubsetSum {
            numbers: vec![1, 2, 3, 4, 5],
            target: 9,
        };

        let submitter = Address::from_bytes([1u8; 32]);
        let bounty = 5000;

        let problem_id = marketplace
            .submit_problem(problem, submitter, bounty, 1.0, 7)
            .unwrap();

        let mut incentives = MiningIncentives::new(marketplace);

        let miner = Address::from_bytes([2u8; 32]);
        let solution = Solution::SubsetSum(vec![1, 2, 3]);

        let result = incentives.submit_mining_solution(problem_id, miner, solution);

        assert!(result.is_ok());
        assert_eq!(result.unwrap(), bounty);
    }

    #[test]
    fn test_incentive_stats() {
        let mut marketplace = ProblemMarketplace::new();

        let problem = ProblemType::SubsetSum {
            numbers: vec![1, 2, 3],
            target: 6,
        };

        let submitter = Address::from_bytes([1u8; 32]);
        marketplace.submit_problem(problem, submitter, 1000, 10.0, 7).unwrap();

        let mut incentives = MiningIncentives::new(marketplace);
        incentives.contribute_to_d3_pool(10000);

        let stats = incentives.get_stats();

        assert!(stats.d3_pool_balance > 0);
        assert_eq!(stats.open_bounties, 1);
        assert_eq!(stats.total_bounty_value, 1000);
        assert_eq!(stats.solved_problems, 0);
    }

    #[test]
    fn test_d3_bonus_calculation() {
        let marketplace = ProblemMarketplace::new();
        let mut incentives = MiningIncentives::new(marketplace);

        // Build up D3 pool
        incentives.contribute_to_d3_pool(100000);

        let marketplace_bounty = 10000;
        let work_score = 80.0; // 80% efficiency

        let bonus = incentives.calculate_d3_bonus(work_score, marketplace_bounty);

        // Bonus should be > 0 but capped
        assert!(bonus > 0);

        // Should not exceed 50% of marketplace bounty
        assert!(bonus <= marketplace_bounty / 2);

        // Should not exceed 10% of D3 pool
        assert!(bonus <= incentives.d3_pool_balance() / 10);
    }
}
